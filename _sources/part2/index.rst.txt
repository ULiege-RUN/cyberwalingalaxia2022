.. CyberwalinGalaxia documentation master file, created by
   sphinx-quickstart on Fri Jun 10 23:25:15 2016.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

################################
Part 2 -- Basic Dynamic Analysis
################################
################################

In the previous section, you studied some basic static binary analysis techniques that allow you to characterize parts of an executable file without actually executing it. As such, these techniques most often involve analyzing the binary code to trace the data and control flows of the executable. Unfortunately, you have seen in the previous section that these techniques can be easily mitigated through obfuscation techniques. In addition, the compilation of higher-level source code often result in very complex binary file that may be very hard to interpret with such basic tools. All in all, such basic analysis technique often fail to provide a complete overview on the actual runtime behavior of binary files.

In this part of the lab, you will tackle such issues using dynamic analysis techniques, thus, completing your toolbox to analyze binary files. The techniques that you will see in this part of the lab will allow your to further characterize the content of binary files by actually studying part of its runtime behavior. In practice, part of this lab will also be dedicated to discover state-of-the-art sandboxing tools that will allow you to execute instruction in a controlled and secure environment. Such tools aims at allowing to perform a runtime analysis of unknown binary file while preventing collateral damages on your testbed, or any device connected to it. In addition, sandboxing tools also ensure that results that you obtain are actually caused by the binary file of interest, and reduce the bias in your observations. 

Dependencies
************

For this part of the practical session, you need the following dependencies to be installed: ``libssl-dev``, ``debootstrap``, ``iwatch`` and ``inetsim``. If they are not installed, you can run the following commands:

.. code-block:: console

   sudo apt install -y libssl-dev debootstrap iwatch inetsim

In addition, the binary file that you will study is the ``malware`` executable (similar to the binary file that you studied in Part 1).

SandBoxing
**********

In cybersecurity, a sandbox is a controlled, isolated execution environment that mimics a given target environment. Such tools allow one to execute programs in a mock environment, minimizing the risk of compromising live systems, while still providing similar runtime features as a target environment.

There exist many tools that can be used for sandboxing ranging from virtualization and containerization techniques to simpler isolation mechanisms such as linux namespaces, chroot jails, etc. In this lab, we will focus on two main aspects of sandboxing: network sandboxing and file system sandboxing.

Network SandBoxing
==================

Network sandboxing refers to tools and techniques that restrict programs to generate network traffic within a controlled and isolated network. The idea is to restrict the communication of a program with external entities as well as to prevent any collateral damages resulting from those communications, e.g. DDoS, botnets synchronization, etc. 

Most UNIX and UNIX-like systems include some sort of system call or other mechanism that can be used to provided network sandboxing capabilities with various level of isolation between the host and the sandbox. In particular, **network namespaces** are linux kernel feature allowing us to isolate network environments through virtualization. For example, using network namespaces, you can create separate network interfaces and routing tables that are isolated from the rest of the system and operate independently.

.. _Using linux network namespace to setup a basic network sandbox:
**Using linux network namespace to setup a basic network sandbox** 

The environment that we will create is a very basic network namespace that will allow us to sniff the traffic initially generated by a program when it starts running. For instance, it can allow us to capture initial DNS queries allowing the program to resolve the domain name of the server it wants to contact. To create a network namespace, called **network-jail-<your_username>**, you can run the command: 

.. code-block:: console

   sudo ip netns add network-jail-<your_username>

Once the namespace **network-jail-<your_username>** has been correctly created, you can execute the program in this network namespace using:

.. code-block:: console

   sudo ip netns exec network-jail-<your_username> ./executable

.. _Using linux network namespace and InetSim to setup a smarter network sandbox:
**Using linux network namespace and InetSim to setup a smarter network sandbox** 

The environment that we will create consist of smarter network namespace in which we will run basic network services to answer the queries issued by our program and to manipulate our answers to redirect towards our other network services. As such, the aim of this sandbox is to dig as deep as possible into the program's execution and generate as much traffic as we can to analyze traffic patterns. To do so, create a network namespace using the previous commands. Then, you can execute both your ``inetsim`` simulator, and the executable of interest in you network namespace using:

.. code-block:: console
   
   terminal1> sudo ip netns exec network-jail-<your_username> sudo inetsim
   terminal2> sudo ip netns exec network-jail-<your_username> ./executable

FileSystem SandBoxing
=====================

Filesystem sandboxing refers to tools and techniques that restrict programs to executing operations in a controlled and isolated file system. The idea is to restrict access to sensitive data and prevent collateral damages when running untrusted programs while still allowing them to proceed with their execution.

Most UNIX and UNIX-like systems include some sort of system call or other mechanism that can be used to provided file system sandboxing capabilities with various level of isolation between the host and the sandbox. In particular, ``chroot`` is a UNIX system call that changes the apparent root directory for a given running process as well as its children. As such, a program that is run in a chrooted environment will sees a normal filesystem while it in fact has a restricted access to a virtual root directory. The goal is to prevent the process from accessing files outside its sandbox. For instance, if you run a program ``foo`` in a chrooted environment, and that this program exploit a vulnerability that allows him to overwrite files in a protected directory, the program will perceive a ``/`` directory and will write relative to that directory, while on the real filesystem it has only access to a virtual root located in ``/path/to/jail`` and has no access to the real ``/`` directory.

.. image:: images/chroot-jail.png
   :width: 600
   :align: center

**Using chroot and deboostrap to setup a filesystem sandbox** 

The environment that we will create is known as “**chroot jail**” or “**jailed directory**”. 

.. note::
   For more information on ``chroot`` and ``deboostrap`` please consult their manpage.

.. note::
   if you are using the setup described in section :ref:`Connect to a remote VM (Kali) already setup <target connect to a remote VM>`, you may not have access to internet for building the jail-directory using ``deboostrap``. To circumvent such issues, you may use the folder ``jail-dir.tar.gz`` (provided within the archive of the lab), decompress it using the command ``tar -xf jail-dir.tar.gz``, and use the resulting folder as a root for your chroot environment. It already contains all needed dependencies for executing your binary file.

First, we will create a minimal, internally-consistent environment in such a way that the program that we will execute thinks that it is run on a legit system. To do so, we will make use of ``deboostrap`` to install a Debian-like base system into a subdirectory. The following command create a minimal virtual root directory located ``/path/to/jail`` based on the amd64 architecture: 

.. code-block:: console

   sudo debootstrap --arch=amd64 --variant=minbase sid /path/to/jail-directory/

Then, you can simply copy the file that you would like to analyze in the sandbox using:

.. code-block:: console

   sudo cp /path/to/executable /path/to/jail-directory/home/

Finally, you can execute the program inside the chrooted environment using:

.. code-block:: console

   sudo chroot /path/to/jail-directory ./home/executable

.. note::
   You may need libraries to execute your program. For instance, the library ``libssl-dev`` can be copy from your host environment to the chrooted environment using ``sudo chroot /path/to/jail-directory apt install libssl-dev``.
   
   Now, any modification induced by the execution of the binary file will be performed on the mocked file system.

Basic Dynamic Analysis -- Communication Monitoring
**************************************************

In this part of the lab, you are asked to monitor the traffic generated by the ``malware`` binary file.

#. Get first insights on the communication using the sandbox setup detailed in the section `Using linux network namespace to setup a basic network sandbox`_.
#. Get further insights on the communication using the sandbox setup detailed in the section `Using linux network namespace and InetSim to setup a smarter network sandbox`_.


Communication Monitoring with Tcpdump
=====================================

The first step of this investigation will be to create a simple network namespace. Then, we will need to perform some configuration to ensure DNS queries are issued by the program:

.. code-block:: console
   
   sudo mkdir -p /etc/netns/network-jail-<your_username>
   echo 'nameserver 127.0.0.1' | sudo tee -a "/etc/netns/network-jail-<your_username>/resolv.conf"
   sudo ip netns exec network-jail-<your_username> ip link set dev lo up

Then, you can sniff the DNS queries generated by you program by running in two different terminals the following commands: 

.. code-block:: console

   terminal1> sudo ip netns exec network-jail-<your_username> tcpdump -w traffic.pcap
   terminal2> sudo ip netns exec network-jail-<your_username> ./executable

Analyze the traffic that you capture with wireshark. You should be able to get the hostname of the server that is contacted by your program.

Communication Monitoring with Tcpdump & InetSim
===============================================

The second step of this investigation will be to perform the same setup but also using ``inetsim``. Thus, the last step is a bit modified:

.. code-block:: console

   terminal1> sudo ip netns exec network-jail-<your_username> sudo inetsim
   terminal2> sudo ip netns exec network-jail-<your_username> tcpdump -w traffic.pcap
   terminal3> sudo ip netns exec network-jail-<your_username> ./executable

Analyze the traffic that you captured with wireshark. Can you decrypt the first message sent by the malware to the server? 

.. note::
   **HINT**: You may want to disable the https server used by ``inetsim`` and setup a custom https server using ``openssl s_server``. To do so, edit the file ``/etc/inetsim/inetsim.conf`` and comment the line starting with ``start_service https``. Then, you can start your openssl server on port 443 using the command ``openssl s_server -port 443 -accept 443 -certs /path/to/your/certificate -key /path/to/your/key``. You can also check the limitations of wireshark regarding TLS decryption `here <https://wiki.wireshark.org/TLS>`_. 
   
   Don't forget to run all of these inside your network namespace for security reasons!


Basic Dynamic Analysis -- File System Events Monitoring
*******************************************************

.. note::
   In the reminder of this lab, you should use the flag ``--localhost`` when running the binary file ``malware`` if you are using the setup described in section :ref:`Connect to a remote VM (Kali) already setup <target connect to a remote VM>`.

In this part of the lab, you are asked to monitor any file system event, e.g. file access, creation, etc, issued by the binary file ``malware``. To do so, you are expected to make use of a chrooted environment that you can monitor using ``iwatch``. ``iwatch`` is a realtime filesystem monitoring program, based on ``inotify`` that allows you to track file system events. As such, you can monitor events in your sandbox using the following command:

.. code-block:: console

   sudo iwatch -r /path/to/jail-directory

.. danger::
   When you run the command ``iwatch``, specifying ``/path/to/jail-directory`` or ``/path/to/jail-directory/`` makes a difference! To account for the whole root directory ``/``, please ensure to avoid the second option.

Once your chrooted environment is setup, you can perform the analysis using the following commands:

.. code-block:: console

   terminal1> sudo iwatch -r /path/to/jail-directory
   terminal2> sudo chroot /path/to/jail-directory ./path/to/malware/in/jail-directory (--localhost)

Analyze the file system events produced by the malware when connectivity is not restricted.

Additional Resources
********************

* For more information on file system sandboxing techniques, their drawbacks, and some benchmarking, please read the following `article <https://lwn.net/Articles/803890/>`_.
